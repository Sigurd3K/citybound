var searchIndex = {};
searchIndex["allocators"] = {"doc":"This tiny crate defines a simple allocator interface.","items":[[3,"DefaultHeap","allocators","An implementation of `Allocator` that allocates using the default heap allocator",null,null],[8,"Allocator","","A trait for all allocators that collections can be generic about",null,null],[10,"allocate","","Allocate enough memory to store `capacity` of `T`",0,null],[10,"deallocate","","Free previously allocated memory from pointer.",0,null],[11,"allocate","","",1,null],[11,"deallocate","","",1,null]],"paths":[[8,"Allocator"],[3,"DefaultHeap"]]};
searchIndex["chunky"] = {"doc":"This crate offers an abstraction over allocating fixed-size chunks of memory and different low-level collection types making use of these chunks to emulate \"infinite\" dynamically growing storages for heterogeneously-sized items.","items":[[3,"Ident","chunky","Identifies a chunk or chunk group uniquely - to be used for persistence",null,null],[12,"0","","",0,null],[3,"HeapHandler","","A `Handler` that allocates chunks on the heap",null,null],[3,"Value","","A single value stored in a chunk",null,null],[3,"ArenaIndex","","Refers to an item within an `Arena`",null,null],[12,"0","","",1,null],[3,"Arena","","Stores items of a fixed (max) size consecutively in a collection of chunks",null,null],[3,"Vector","","A vector which stores items of a known type in an `Arena`",null,null],[3,"Queue","","A FIFO queue which stores heterogeneously sized items",null,null],[3,"MultiArenaIndex","","Refers to an item in a `MultiArena`",null,null],[12,"0","","",2,null],[12,"1","","",2,null],[3,"MultiArena","","Based on a collection type for fixed-size items (\"Bin\"), creates a collection for heterogenously-sized items which will be stored in the most appropriately-sized bin.",null,null],[8,"Handler","","A strategy for managing chunks",null,null],[10,"create_chunk","","Create a new chunk with a given identifier, assumes it doesn't exist",3,null],[10,"load_or_create_chunk","","Load a chunk with a given identifier, or create it if it doesn't exist",3,null],[10,"load_chunk","","Load a chunk with a given identifier, assumes it exists",3,null],[10,"unload_chunk","","Deallocate a chunk, but keep any persisted representation of it",3,null],[10,"destroy_chunk","","Deallocate a chunk and delete any persisted representation of it",3,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"ident"}}],[11,"sub","","Create a sub-identifier within a group",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"ident"}}],[11,"from","","",0,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"create_chunk","","",4,null],[11,"load_or_create_chunk","","",4,null],[11,"load_chunk","","",4,null],[11,"unload_chunk","","",4,null],[11,"destroy_chunk","","",4,null],[11,"load_or_default","","Load the value in the chunk with the given identifier, or create it using a default value",5,{"inputs":[{"name":"ident"},{"name":"v"}],"output":{"name":"value"}}],[11,"deref","","",5,{"inputs":[{"name":"self"}],"output":{"name":"v"}}],[11,"deref_mut","","",5,{"inputs":[{"name":"self"}],"output":{"name":"v"}}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"arenaindex"}}],[11,"new","","Create a new arena given a chunk group identifier, chunk size and (max) item size",6,{"inputs":[{"name":"ident"},{"name":"usize"},{"name":"usize"}],"output":{"name":"arena"}}],[11,"len","","Number of elements in the collection",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the collection empty?",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Allocate space for a new item, returns a pointer to where the new item can be written to and the index that the new item will have.",6,null],[11,"pop_away","","Remove the last item from the end",6,{"inputs":[{"name":"self"}],"output":null}],[11,"swap_remove","","Remove the item at index, by swapping it with the last item and then popping, returning the swapped in item (unless empty).",6,{"inputs":[{"name":"self"},{"name":"arenaindex"}],"output":{"name":"option"}}],[11,"at","","Get a pointer to the item at `index`",6,null],[11,"at_mut","","Get a mutable pointer to the item at `index`",6,null],[11,"new","","Create a new chunky vector",7,{"inputs":[{"name":"ident"},{"name":"usize"}],"output":{"name":"self"}}],[11,"len","","Get the number of elements in the vector",7,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the chunky vector empty?",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"at","","Get a reference to the item at `index`",7,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"item"}}],[11,"at_mut","","Get a mutable reference to the item at `index`",7,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"item"}}],[11,"push","","Push an item onto the vector",7,{"inputs":[{"name":"self"},{"name":"item"}],"output":null}],[11,"pop","","Remove and return the last item, if the vector wasn't empty",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new queue",8,{"inputs":[{"name":"ident"},{"name":"usize"}],"output":{"name":"self"}}],[11,"len","","Number of items in the queue",8,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the queue empty?",8,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enqueue","","Enqueue an item of a given size. Returns a pointer that the item can be written to.",8,null],[11,"dequeue","","Dequeue an item. Returns a pointer to the item in the queue, unless the queue is empty.",8,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop_old_chunks","","Delete chunks which have already been read",8,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"multiarenaindex"}}],[11,"new","","Create a new `MultiArena` collection using `Arena` bins and a base size that represents the smallest expected item size (used as the item size of the smallest-sized bin)",9,{"inputs":[{"name":"ident"},{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"size_to_index","","Get the index of the Bin which stores items of size `size`",9,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"at","","Get an (untyped) pointer to the item at the given index",9,null],[11,"at_mut","","Get an (untyped) mutable pointer to the item at the given index",9,null],[11,"push","","Add an item to the end of the bin corresponding to its size",9,null],[11,"swap_remove_within_bin","","Remove the item referenced by `index` from its bin by swapping with the bin's last item",9,{"inputs":[{"name":"self"},{"name":"multiarenaindex"}],"output":{"name":"option"}}],[11,"populated_bin_indices_and_lens","","Return indices of bins that actually contain items and their respective lengths",9,null],[11,"bin_len","","Get the length of the bin of the given bin index",9,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"usize"}}]],"paths":[[3,"Ident"],[3,"ArenaIndex"],[3,"MultiArenaIndex"],[8,"Handler"],[3,"HeapHandler"],[3,"Value"],[3,"Arena"],[3,"Vector"],[3,"Queue"],[3,"MultiArena"]]};
searchIndex["compact"] = {"doc":"This crate makes it possible to store objects containing dynamic fields either compactly in consecutive memory or using traditional heap pointers.","items":[[3,"COption","compact","A wrapper to make an `Option` of a nontrivial `Compact` possible. Unfortunately, we can't blanket-`impl` that, since that overlaps (for the compiler) with the `impl` for trivial `Copy` types...",null,null],[12,"0","","",0,null],[3,"CVec","","A dynamically-sized vector that can be stored in compact sequential storage and automatically spills over into free heap storage using `Allocator`. Tries to closely follow the API of `std::vec::Vec`, but is not complete.",null,null],[3,"CString","","A compact storage for a `String`. So far doesn't support direct mutable operations, Only conversion from and to `String`/`&str`",null,null],[3,"CDict","","A simple linear-search key-value dictionary, implemented using two `CompactVec`'s, one for keys, one for values.",null,null],[3,"CHashMap","","A dynamically-sized open adressing quadratic probing hashmap that can be stored in compact sequential storage and automatically spills over into free heap storage using `Allocator`.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"compactoption"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"compactoption"}}],[11,"deref","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"deref_mut","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",0,null],[11,"decompact","","",0,null],[11,"len","","Get the number of elements in the vector",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the vector empty?",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Create a new, empty vector",1,{"inputs":[],"output":{"name":"compactvec"}}],[11,"with_capacity","","Create a new, empty vector with a given capacity",1,{"inputs":[{"name":"usize"}],"output":{"name":"compactvec"}}],[11,"from_raw_parts","","Create a new vector from raw parts Assumes that `ptr` has been allocated by the same Allocator that is `A`",1,null],[11,"capacity","","current capacity",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"push","","Push an item onto the vector, spills onto the heap if the capacity in compact storage is insufficient",1,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"push_at","","push at position",1,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"t"}],"output":null}],[11,"extend_from_copy_slice","","Extend from a copyable slice",1,null],[11,"pop","","Pop and return the last element, if the vector wasn't empty",1,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"insert","","Insert a value at `index`, copying the elements after `index` upwards",1,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"t"}],"output":null}],[11,"remove","","Remove the element at `index`, copying the elements after `index` downwards",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"retain","","Take a function which returns whether an element should be kept, and mutably removes all elements from the vector which are not kept",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"truncate","","Truncate the vector to the given length",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"clear","","Clear the vector",1,{"inputs":[{"name":"self"}],"output":null}],[11,"drain","","Drain (empty & iterate over) the vector",1,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"ptr_to_string","","debug printing",1,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"from","","Create a `CompactVec` from a normal `Vec`, directly using the backing storage as free heap storage",1,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"drop","","Drop elements and deallocate free heap storage, if any is allocated",1,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"into_iter","","",1,null],[11,"is_still_compact","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",1,null],[11,"decompact","","",1,null],[11,"is_still_compact","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"compactvec"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"compactvec"}}],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",1,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"default","","",1,{"inputs":[],"output":{"name":"compactvec"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"compactstring"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"compactstring"}}],[11,"new","","Create an empty `CString`",2,{"inputs":[],"output":{"name":"self"}}],[11,"push_str","","Appends a given string slice onto the end of this `CString`.",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":null}],[11,"deref","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from","","",2,{"inputs":[{"name":"string"}],"output":{"name":"compactstring"}}],[11,"is_still_compact","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",2,null],[11,"decompact","","",2,null],[11,"new","","Create new, empty dictionary",3,{"inputs":[],"output":{"name":"self"}}],[11,"len","","Amount of entries in the dictionary",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the dictionary empty?",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get","","Look up the value for key `query`, if it exists",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mut","","Look up the value for keu `query` mutably, if it exists",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mru","","Lookup up the value for key `query`, if it exists, but also swap the entry to the beginning of the key/value vectors, so a repeated lookup for that item will be faster",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mfu","","Lookup up the value for key `query`, if it exists, but also swap the entry one index towards the beginning of the key/value vectors, so frequently repeated lookups for that item will be faster",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"contains_key","","Does the dictionary contain a value for `query`?",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"bool"}}],[11,"insert","","Insert new value at key `query` and return the previous value at that key, if any existed",3,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Remove value at key `query` and return it, if it existed",3,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"keys","","Iterator over all keys in the dictionary",3,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"values","","Iterator over all values in the dictionary",3,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"values_mut","","Iterator over mutable references to all values in the dictionary",3,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"pairs","","Iterator over all key-value pairs in the dictionary",3,null],[11,"push_at","","Push a value onto the `CompactVec` at the key `query`",3,{"inputs":[{"name":"self"},{"name":"k"},{"name":"i"}],"output":null}],[11,"get_iter","","Iterator over the `CompactVec` at the key `query`",3,null],[11,"remove_iter","","Remove the `CompactVec` at the key `query` and iterate over its elements (if it existed)",3,null],[11,"is_still_compact","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",3,null],[11,"decompact","","",3,null],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","Construct a compact dictionary from an interator over key-value pairs",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"extend","","Extend a compact dictionary from an iterator over key-value pairs",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"new","","constructor",4,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","constructor",4,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"len","","Amount of entries in the dictionary",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the dictionary empty?",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get","","Look up the value for key `query`, if it exists",4,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mut","","get mutable",4,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"contains_key","","Does the dictionary contain a value for `query`?",4,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"bool"}}],[11,"insert","","Insert new value at key `query` and return the previous value at that key, if any existed",4,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Remove value at key `query` and return it, if it existed",4,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"keys","","Iterator over all keys in the dictionary",4,null],[11,"values","","Iterator over all values in the dictionary",4,null],[11,"values_mut","","Iterator over mutable references to all values in the dictionary",4,null],[11,"pairs","","Iterator over all key-value pairs in the dictionary",4,null],[11,"pairs_mut","","",4,null],[11,"is_still_compact","","",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",4,null],[11,"decompact","","",4,null],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","Construct a compact dictionary from an interator over key-value pairs",4,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"push_at","","Push a value onto the `CompactVec` at the key `query`",4,{"inputs":[{"name":"self"},{"name":"k"},{"name":"i"}],"output":null}],[11,"get_iter","","Iterator over the `CompactVec` at the key `query`",4,null],[11,"remove_iter","","Remove the `CompactVec` at the key `query` and iterate over its elements (if it existed)",4,null],[11,"hash","","",1,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[8,"Compact","","A trait for objects with a statically-sized part and a potential dynamically-sized part that can be stored both compactly in consecutive memory or freely on the heap",null,null],[10,"is_still_compact","","Is the object's dynamic part stored compactly?",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"dynamic_size_bytes","","Size of the dynamic part in bytes",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"compact","","Copy the static part of `source` to `dest` and compactly store the dynamic part of `source` as the new dynamic part of `dest` at `new_dynamic_part`. This semantically moves source into dest.",5,null],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",5,null],[11,"compact_behind","","Like `compact` with `new_dynamic_part` set to `dest.behind()`",5,null],[10,"decompact","","Creates a clone of self with the dynamic part guaranteed to be stored freely.",5,null],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",5,null],[11,"compact_behind","","Like `compact` with `new_dynamic_part` set to `dest.behind()`",5,null]],"paths":[[3,"COption"],[3,"CVec"],[3,"CString"],[3,"CDict"],[3,"CHashMap"],[8,"Compact"]]};
searchIndex["compact_macros"] = {"doc":"Automatic `#[derive(Compact)]` macro for structs whose fields are all `Compact`","items":[[5,"derive_compact","compact_macros","",null,{"inputs":[{"name":"tokenstream"}],"output":{"name":"tokenstream"}}]],"paths":[]};
searchIndex["descartes"] = {"doc":"","items":[[5,"try_inverse","descartes","Tries to gets an inverted copy of a square matrix.",null,{"inputs":[{"name":"m"}],"output":{"name":"option"}}],[3,"Circle","","",null,null],[12,"center","","",0,null],[12,"radius","","",0,null],[3,"Line","","",null,null],[12,"start","","",1,null],[12,"direction","","",1,null],[3,"Segment","","",null,null],[12,"start","","",2,null],[12,"center_or_direction","","",2,null],[12,"end","","",2,null],[12,"length","","",2,null],[3,"Intersection","","",null,null],[12,"along_a","","",3,null],[12,"along_b","","",3,null],[12,"position","","",3,null],[3,"Band","","",null,null],[12,"path","","",4,null],[12,"width","","",4,null],[3,"BoundingBox","","",null,null],[12,"min","","",5,null],[12,"max","","",5,null],[4,"ShapeError","","",null,null],[13,"NotClosed","","",6,null],[4,"PointOnShapeLocation","","",null,null],[13,"Inside","","",7,null],[13,"OnEdge","","",7,null],[13,"Outside","","",7,null],[5,"angle_to","","",null,{"inputs":[{"name":"v2"},{"name":"v2"}],"output":{"name":"n"}}],[5,"angle_along_to","","",null,{"inputs":[{"name":"v2"},{"name":"v2"},{"name":"v2"}],"output":{"name":"n"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"circle"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"project_with_tolerance","","",0,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"generics":["n"],"name":"option"}}],[11,"distance_to","","",0,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"line"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"project_with_tolerance","","",1,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"generics":["n"],"name":"option"}}],[11,"distance_to","","",1,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"segment"}}],[11,"line","","",2,{"inputs":[{"name":"p2"},{"name":"p2"}],"output":{"generics":["segment"],"name":"option"}}],[11,"arc_with_direction","","",2,{"inputs":[{"name":"p2"},{"name":"v2"},{"name":"p2"}],"output":{"generics":["segment"],"name":"option"}}],[11,"biarc","","",2,{"inputs":[{"name":"p2"},{"name":"v2"},{"name":"p2"},{"name":"v2"}],"output":{"generics":["vec"],"name":"option"}}],[11,"is_linear","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"center","","",2,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"radius","","",2,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"signed_angle","","",2,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"to_svg","","",2,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"length","","",2,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"along","","",2,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"p2"}}],[11,"direction_along","","",2,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"v2"}}],[11,"start","","",2,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"start_direction","","",2,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"end","","",2,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"end_direction","","",2,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"reverse","","",2,{"inputs":[{"name":"self"}],"output":{"name":"segment"}}],[11,"subsection","","",2,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"generics":["segment"],"name":"option"}}],[11,"shift_orthogonally","","",2,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"generics":["segment"],"name":"option"}}],[11,"project_with_tolerance","","",2,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"generics":["n"],"name":"option"}}],[11,"includes","","",2,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"distance_to","","",2,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"bounding_box","","",2,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"intersection"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"location_of","","",0,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"pointonshapelocation"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"band"}}],[11,"new","","",4,{"inputs":[{"name":"p"},{"name":"n"}],"output":{"name":"band"}}],[11,"outline","","",4,{"inputs":[{"name":"self"}],"output":{"name":"p"}}],[11,"outline_distance_to_path_distance","","",4,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"n"}}],[11,"location_of","","",4,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"pointonshapelocation"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"clipper","","",null,null],[4,"Mode","descartes::clipper","",null,null],[13,"Intersection","","",8,null],[13,"Union","","",8,null],[13,"Difference","","",8,null],[13,"Not","","",8,null],[13,"Split","","",8,null],[4,"Role","","",null,null],[13,"None","","",9,null],[13,"Entry","","",9,null],[13,"Exit","","",9,null],[13,"EntryExit","","",9,null],[13,"ExitEntry","","",9,null],[4,"Direction","","",null,null],[13,"ForwardStay","","",10,null],[13,"ForwardSwitch","","",10,null],[13,"BackwardStay","","",10,null],[13,"BackwardSwitch","","",10,null],[4,"ClipError","","",null,null],[13,"UnimplementedTransition","","",11,null],[13,"ImpossibleTransition","","",11,null],[13,"InvalidSegmentBetweenIntersections","","",11,null],[13,"InvalidResultPath","","",11,null],[13,"InvalidResultShape","","",11,null],[13,"UnimplementedComplexResult","","",11,null],[13,"InfiniteLoop","","",11,null],[5,"clip","","",null,{"inputs":[{"name":"mode"},{"name":"s"},{"name":"s"}],"output":{"generics":["vec","cliperror"],"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"mode"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"role"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"role"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"direction"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"N","descartes","",null,null],[6,"V2","","",null,null],[6,"P2","","",null,null],[6,"V3","","",null,null],[6,"V4","","",null,null],[6,"P3","","",null,null],[6,"M4","","",null,null],[6,"Iso3","","",null,null],[6,"Aff3","","",null,null],[6,"Persp3","","",null,null],[17,"MIN_START_TO_END","","",null,null],[8,"Path","","",null,null],[10,"segments","","",12,null],[10,"new_unchecked","","",12,{"inputs":[{"generics":["segment"],"name":"vec"}],"output":{"name":"self"}}],[11,"new","","",12,{"inputs":[{"generics":["segment"],"name":"vec"}],"output":{"generics":["patherror"],"name":"result"}}],[11,"new_welded","","",12,{"inputs":[{"generics":["segment"],"name":"vec"}],"output":{"generics":["patherror"],"name":"result"}}],[11,"scan_segments","","",12,{"inputs":[{"name":"startoffsetstate"},{"name":"segment"}],"output":{"name":"option"}}],[11,"segments_with_start_offsets","","",12,{"inputs":[{"name":"self"}],"output":{"generics":["iter","startoffsetstate"],"name":"scan"}}],[11,"find_on_segment","","",12,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains","","",12,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"self_intersections","","",12,{"inputs":[{"name":"self"}],"output":{"generics":["intersection"],"name":"vec"}}],[11,"is_closed","","",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"concat","","",12,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"generics":["patherror"],"name":"result"}}],[11,"to_svg","","",12,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"from_svg","","",12,{"inputs":[{"name":"str"}],"output":{"generics":["patherror"],"name":"result"}}],[8,"Intersect","","",null,null],[10,"intersect","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["intersection"],"name":"vec"}}],[8,"SimpleShape","","",null,null],[16,"P","","",14,null],[10,"outline","","",14,null],[11,"new","","",14,null],[10,"new_unchecked","","",14,null],[8,"WithUniqueOrthogonal","","",null,null],[10,"orthogonal","","",15,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[8,"RelativeToBasis","","",null,null],[10,"to_basis","","",16,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"from_basis","","",16,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"Into2d","","",null,null],[16,"Target","","",17,null],[10,"into_2d","","",17,null],[8,"Into3d","","",null,null],[16,"Target","","",18,null],[10,"into_3d","","",18,null],[8,"RoughlyComparable","","",null,null],[11,"is_roughly","","",19,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[10,"is_roughly_within","","",19,{"inputs":[{"name":"self"},{"name":"self"},{"name":"n"}],"output":{"name":"bool"}}],[8,"Curve","","",null,null],[11,"project_with_max_distance","","",20,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"},{"name":"n"}],"output":{"generics":["n"],"name":"option"}}],[10,"project_with_tolerance","","",20,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"generics":["n"],"name":"option"}}],[11,"project","","",20,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"generics":["n"],"name":"option"}}],[11,"includes","","",20,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[10,"distance_to","","",20,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[8,"FiniteCurve","","",null,null],[10,"length","","",21,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[10,"along","","",21,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"p2"}}],[11,"midpoint","","",21,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[10,"direction_along","","",21,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"v2"}}],[10,"start","","",21,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"start_direction","","",21,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[10,"end","","",21,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"end_direction","","",21,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[10,"reverse","","",21,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"subsection","","",21,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[10,"shift_orthogonally","","",21,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[8,"Shape","","",null,null],[11,"contains","","",22,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[10,"location_of","","",22,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"pointonshapelocation"}}],[8,"HasBoundingBox","","",null,null],[10,"bounding_box","","",23,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"orthogonal","","",24,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"to_basis","","",24,{"inputs":[{"name":"self"},{"name":"v2"}],"output":{"name":"v2"}}],[11,"from_basis","","",24,{"inputs":[{"name":"self"},{"name":"v2"}],"output":{"name":"v2"}}],[11,"into_2d","","",25,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"into_2d","","",26,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"into_3d","","",24,{"inputs":[{"name":"self"}],"output":{"name":"v3"}}],[11,"into_3d","","",27,{"inputs":[{"name":"self"}],"output":{"name":"p3"}}],[11,"is_roughly_within","","",28,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_roughly_within","","",27,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_roughly_within","","",24,{"inputs":[{"name":"self"},{"name":"v2"},{"name":"n"}],"output":{"name":"bool"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"pointonshapelocation"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"pointonshapelocation"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"infinite","","",5,{"inputs":[],"output":{"name":"self"}}],[11,"overlaps","","",5,{"inputs":[{"name":"self"},{"name":"boundingbox"}],"output":{"name":"bool"}}],[11,"point","","",5,{"inputs":[{"name":"p2"}],"output":{"name":"self"}}],[11,"grown_by","","",5,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"self"}}],[11,"new","","",12,{"inputs":[{"generics":["segment"],"name":"vec"}],"output":{"generics":["patherror"],"name":"result"}}],[11,"new_welded","","",12,{"inputs":[{"generics":["segment"],"name":"vec"}],"output":{"generics":["patherror"],"name":"result"}}],[11,"scan_segments","","",12,{"inputs":[{"name":"startoffsetstate"},{"name":"segment"}],"output":{"name":"option"}}],[11,"segments_with_start_offsets","","",12,{"inputs":[{"name":"self"}],"output":{"generics":["iter","startoffsetstate"],"name":"scan"}}],[11,"find_on_segment","","",12,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains","","",12,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"self_intersections","","",12,{"inputs":[{"name":"self"}],"output":{"generics":["intersection"],"name":"vec"}}],[11,"is_closed","","",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"concat","","",12,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"generics":["patherror"],"name":"result"}}],[11,"to_svg","","",12,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"from_svg","","",12,{"inputs":[{"name":"str"}],"output":{"generics":["patherror"],"name":"result"}}],[11,"new","","",14,null]],"paths":[[3,"Circle"],[3,"Line"],[3,"Segment"],[3,"Intersection"],[3,"Band"],[3,"BoundingBox"],[4,"ShapeError"],[4,"PointOnShapeLocation"],[4,"Mode"],[4,"Role"],[4,"Direction"],[4,"ClipError"],[8,"Path"],[8,"Intersect"],[8,"SimpleShape"],[8,"WithUniqueOrthogonal"],[8,"RelativeToBasis"],[8,"Into2d"],[8,"Into3d"],[8,"RoughlyComparable"],[8,"Curve"],[8,"FiniteCurve"],[8,"Shape"],[8,"HasBoundingBox"],[6,"V2"],[6,"V3"],[6,"P3"],[6,"P2"],[6,"N"]]};
searchIndex["kay"] = {"doc":"`Kay` is a high-performance actor system, suitable for simulating millions of entities.","items":[[3,"Packet","kay","Combination of a message and its destination recipient id",null,null],[12,"recipient_id","","RawID of the `Actor`/`Actor` that should receive this message",0,null],[12,"message","","The message itself",0,null],[3,"RawID","","A `RawID` uniquely identifies an `Actor`, or even a `Actor` within a `Swarm`",null,null],[12,"type_id","","An ID for the type of the identified `Actor`, used to dispatch messages to the message handling functions registered for this type",1,null],[12,"machine","","ID of the machine (in a computing cluster or multiplayer environment) that the identified `Actor` lives on",1,null],[12,"version","","Allows safe reuse of a `RawID` after `Actor`/`Actor` death. The version is incremented to make the new (otherwise identical) `RawID` distinguishable from erroneous references to the `Actor`/`Actor` previously identified",1,null],[12,"instance_id","","Used to identify instances within a top-level `Actor`. The main use-case is `Swarm` identifying and dispatching to its `Instances` using this field",1,null],[3,"MachineID","","",null,null],[12,"0","","",2,null],[3,"ActorSystem","","The main thing inside of which all the magic happens.",null,null],[12,"panic_happened","","Flag that the system is in a panicked state",3,null],[12,"shutting_down","","Flag that the system is shutting down",3,null],[3,"World","","Gives limited access to an `ActorSystem` (typically from inside, in a message handler) to identify other actors and send messages to them.",null,null],[3,"Networking","","Represents all networking environment and networking state of an `ActorSystem`",null,null],[12,"machine_id","","The machine index of this machine within the network of peers",4,null],[12,"n_turns","","The current network turn this machine is in. Used to keep track if this machine lags behind or runs fast compared to its peers",4,null],[3,"External","","An owning reference to local state outside the actor system that can safely be embedded in actor states and passed in messages, as long as they stay on one machine.",null,null],[4,"Fate","","Return type of message handling functions, signifying if an `Actor`/`Actor` should live on after receiving a certain message type.",null,null],[13,"Live","","Means: the `Actor`/`Actor` should live on",5,null],[13,"Die","","Means: the `Actor`/`Actor` should be stopped, its state can be deallocated",5,null],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",0,null],[11,"decompact","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"packet"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"machineid"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"machineid"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"machineid"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"self"},{"name":"machineid"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"self"},{"name":"machineid"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"self"},{"name":"machineid"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"self"},{"name":"machineid"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"self"},{"name":"machineid"}],"output":{"name":"bool"}}],[11,"cmp","","",2,{"inputs":[{"name":"self"},{"name":"machineid"}],"output":{"name":"ordering"}}],[11,"hash","","",2,null],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"rawid"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"rawid"}],"output":{"name":"bool"}}],[11,"hash","","",1,null],[11,"new","","Create a new `RawID`",1,{"inputs":[{"name":"shorttypeid"},{"name":"u32"},{"name":"machineid"},{"name":"u8"}],"output":{"name":"self"}}],[11,"local_broadcast","","Get a version of an actor `RawID` that signals that a message should be delivered to all machine-local instances.",1,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"global_broadcast","","Get a version of an actor `RawID` that signals that a message should be delivered globally (to all instances on all machines).",1,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"is_broadcast","","Check whether this `RawID` signals a local or global broadcast.",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_global_broadcast","","Check whether this `RawID` signals specifically a global broadcast.",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new ActorSystem (usually only one per application is needed). Expects to get a panic callback as a parameter that is called when an actor panics during message handling and can thus be used to for example display the panic error message.",3,{"inputs":[{"name":"networking"}],"output":{"name":"actorsystem"}}],[11,"register","","Register a new Actor type with the system",3,{"inputs":[{"name":"self"}],"output":null}],[11,"add_handler","","Register a handler for an Actor type and Message type.",3,{"inputs":[{"name":"self"},{"name":"f"},{"name":"bool"}],"output":null}],[11,"add_spawner","","Register a handler that constructs an instance of an Actor type, given an RawID",3,{"inputs":[{"name":"self"},{"name":"f"},{"name":"bool"}],"output":null}],[11,"send","","Send a message to the actor(s) with a given `RawID`. This is only used to send messages into the system from outside. Inside actor message handlers you always have access to a `World` that allows you to send messages.",3,{"inputs":[{"name":"self"},{"name":"rawid"},{"name":"m"}],"output":null}],[11,"id","","Get the base RawID of an Actor type",3,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"process_all_messages","","Processes all sent messages, and messages which are in turn sent during the handling of messages, up to a recursion depth of 1000.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"world","","Get a world context directly from the system, typically to send messages from outside",3,{"inputs":[{"name":"self"}],"output":{"name":"world"}}],[11,"networking_connect","","Connect to all peers in the network",3,{"inputs":[{"name":"self"}],"output":null}],[11,"networking_send_and_receive","","Send queued outbound messages and take incoming queued messages and forward them to their local target recipient(s)",3,{"inputs":[{"name":"self"}],"output":null}],[11,"networking_finish_turn","","Finish the current networking turn and wait for peers which lag behind based on their turn number. This is the main backpressure mechanism.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"networking_machine_id","","The machine index of this machine within the network of peers",3,{"inputs":[{"name":"self"}],"output":{"name":"machineid"}}],[11,"networking_n_turns","","The current network turn this machine is in. Used to keep track if this machine lags behind or runs fast compared to its peers",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"networking_debug_all_n_turns","","Return a debug message containing the current local view of network turn progress of all peers in the network",3,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"get_instance_counts","","Access to debugging statistics",3,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"send","","Send a message to a (sub-)actor with the given RawID.",6,{"inputs":[{"name":"self"},{"name":"rawid"},{"name":"m"}],"output":null}],[11,"local_first","","Get the RawID of the first machine-local instance of an actor.",6,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"global_first","","Get the RawID of the first instance of an actor on machine 0",6,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"local_broadcast","","Get the RawID for a broadcast to all machine-local instances of an actor.",6,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"global_broadcast","","Get the RawID for a global broadcast to all instances of an actor on all machines.",6,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"allocate_instance_id","","Synchronously allocate a instance id for a instance that will later manually be added to a Swarm",6,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[11,"local_machine_id","","Get the id of the machine that we're currently in",6,{"inputs":[{"name":"self"}],"output":{"name":"machineid"}}],[11,"shutdown","","Signal intent to shutdown the actor system",6,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Create network environment based on this machines id/index and all peer addresses (including this machine)",4,{"inputs":[{"name":"u8"},{"generics":["socketaddr"],"name":"vec"}],"output":{"name":"networking"}}],[11,"connect","","Connect to all peers in the network",4,{"inputs":[{"name":"self"}],"output":null}],[11,"finish_turn","","Finish the current networking turn and wait for peers which lag behind based on their turn number. This is the main backpressure mechanism.",4,null],[11,"send_and_receive","","Send queued outbound messages and take incoming queued messages and forward them to their local target recipient(s)",4,null],[11,"enqueue","","Enqueue a new (potentially) outbound packet",4,{"inputs":[{"name":"self"},{"name":"shorttypeid"},{"name":"packet"}],"output":null}],[11,"debug_all_n_turns","","Return a debug message containing the current local view of network turn progress of all peers in the network",4,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"new","","Allocate `content` on the heap and create a sharable `External` reference to it",7,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"from_box","","To interface with traditional owned boxes",7,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"steal","","Like `clone`, just to make the danger more clear",7,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"into_box","","To interface with traditional owned boxes",7,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"deref","","",7,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",7,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"is_still_compact","","",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",7,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact","","",7,null],[11,"decompact","","",7,null],[8,"Message","","Trait that a datastructure must implement in order to be sent and received as a message.",null,null],[8,"TypedID","","`TypedID` is a construct on top of a `RawID` that can refer to a specific kind of actor, or actor trait at compile time",null,null],[10,"as_raw","","Get the underlying `RawID`",8,{"inputs":[{"name":"self"}],"output":{"name":"rawid"}}],[10,"from_raw","","Construct a new `TypedID` from a `RawID` - this implies knowledge about the type of actor referenced by the `RawID`",8,{"inputs":[{"name":"rawid"}],"output":{"name":"self"}}],[8,"Actor","","Trait that Actors instance have to implement for a `Swarm` so their internally stored instance `RawID` can be gotten and set.",null,null],[16,"ID","","The unique `TypedID` of this actor",9,null],[10,"id","","Get `TypedID` of this actor",9,null],[10,"set_id","","Set the full RawID (Actor type id + instance id) of this actor (only used internally by `Swarm`)",9,{"inputs":[{"name":"self"},{"name":"rawid"}],"output":null}],[11,"id_as","","Get the id of this actor as an actor trait `TypedID` (available if the actor implements the corresponding trait)",9,{"inputs":[{"name":"self"}],"output":{"name":"targetid"}}],[11,"local_first","","Get the `TypedID` of the local first actor of this kind",9,null],[11,"global_first","","Get the `TypedID` of the global first actor of this kind",9,null],[11,"local_broadcast","","Get the `TypedID` representing a local broadcast to actors of this type",9,null],[11,"global_broadcast","","Get the `TypedID` representing a global broadcast to actors of this type",9,null],[8,"TraitIDFrom","","Helper trait that signifies that an actor's `TypedID` can be converted to an actor trait `TypedID` if that actor implements the corresponding trait.",null,null],[11,"from","","Construct the actor trait `TypedID` from an actor's `TypedID`",10,null],[11,"id_as","","Get the id of this actor as an actor trait `TypedID` (available if the actor implements the corresponding trait)",9,{"inputs":[{"name":"self"}],"output":{"name":"targetid"}}],[11,"local_first","","Get the `TypedID` of the local first actor of this kind",9,null],[11,"global_first","","Get the `TypedID` of the global first actor of this kind",9,null],[11,"local_broadcast","","Get the `TypedID` representing a local broadcast to actors of this type",9,null],[11,"global_broadcast","","Get the `TypedID` representing a global broadcast to actors of this type",9,null],[11,"from","","Construct the actor trait `TypedID` from an actor's `TypedID`",10,null]],"paths":[[3,"Packet"],[3,"RawID"],[3,"MachineID"],[3,"ActorSystem"],[3,"Networking"],[4,"Fate"],[3,"World"],[3,"External"],[8,"TypedID"],[8,"Actor"],[8,"TraitIDFrom"]]};
searchIndex["kay_codegen"] = {"doc":"","items":[[3,"Model","kay_codegen","",null,null],[12,"actors","","",0,null],[12,"traits","","",0,null],[3,"ActorDef","","",null,null],[12,"handlers","","",1,null],[12,"impls","","",1,null],[12,"defined_here","","",1,null],[3,"TraitDef","","",null,null],[12,"handlers","","",2,null],[3,"Handler","","",null,null],[4,"HandlerType","","",null,null],[13,"Handler","","",3,null],[13,"Init","","",3,null],[5,"scan_and_generate","","",null,{"inputs":[{"name":"str"}],"output":null}],[5,"generate","","",null,{"inputs":[{"name":"model"}],"output":{"name":"string"}}],[11,"map_handlers","","",1,{"inputs":[{"name":"self"},{"name":"ty"},{"name":"handlerorigin"},{"name":"handlertype"},{"name":"f"}],"output":{"name":"vec"}}],[11,"map_handlers","","",2,{"inputs":[{"name":"self"},{"name":"path"},{"name":"handlertype"},{"name":"f"}],"output":{"name":"vec"}}],[11,"map_handlers","","",0,null],[11,"map_handlers_args","","",0,null],[11,"map_trait_handlers","","",0,null],[11,"map_trait_handlers_args","","",0,null],[11,"generate_setups","","",0,{"inputs":[{"name":"self"}],"output":{"name":"tokens"}}],[11,"generate_traits","","",0,{"inputs":[{"name":"self"}],"output":{"name":"tokens"}}],[11,"generate_actor_ids_messages_and_conversions","","",0,{"inputs":[{"name":"self"}],"output":{"name":"tokens"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"model"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"actordef"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"traitdef"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"handler"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"handlertype"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"handlertype"}],"output":{"name":"bool"}}]],"paths":[[3,"Model"],[3,"ActorDef"],[3,"TraitDef"],[4,"HandlerType"],[3,"Handler"]]};
initSearch(searchIndex);
